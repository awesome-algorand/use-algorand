// This file is auto-generated by @hey-api/openapi-ts
export class PrivateService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * Retrieves the current settings for blocking and mutex profiles
     * @returns DebugSettingsProf DebugPprof is the response to the /debug/extra/pprof endpoint
     * @throws ApiError
     */
    getDebugSettingsProf() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/debug/settings/pprof'
        });
    }
    /**
     * Enables blocking and mutex profiles, and returns the old settings
     * @returns DebugSettingsProf DebugPprof is the response to the /debug/extra/pprof endpoint
     * @throws ApiError
     */
    putDebugSettingsProf() {
        return this.httpRequest.request({
            method: 'PUT',
            url: '/debug/settings/pprof'
        });
    }
    /**
     * Aborts a catchpoint catchup.
     * Given a catchpoint, it aborts catching up to this catchpoint
     * @param data The data for the request.
     * @param data.catchpoint A catch point
     * @returns unknown
     * @throws ApiError
     */
    abortCatchup(data) {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/v2/catchup/{catchpoint}',
            path: {
                catchpoint: data.catchpoint
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Starts a catchpoint catchup.
     * Given a catchpoint, it starts catching up to this catchpoint
     * @param data The data for the request.
     * @param data.catchpoint A catch point
     * @param data.min Specify the minimum number of blocks which the ledger must be advanced by in order to start the catchup. This is useful for simplifying tools which support fast catchup, they can run the catchup unconditionally and the node will skip the catchup if it is not needed.
     * @returns unknown
     * @returns unknown
     * @throws ApiError
     */
    startCatchup(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/catchup/{catchpoint}',
            path: {
                catchpoint: data.catchpoint
            },
            query: {
                min: data.min
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                408: 'Request Timeout',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Return a list of participation keys
     * Return a list of participation keys
     * @returns ParticipationKey A list of participation keys
     * @throws ApiError
     */
    getParticipationKeys() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/participation',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Add a participation key to the node
     * @param data The data for the request.
     * @param data.requestBody The participation key to add to the node
     * @returns unknown Participation ID of the submission
     * @throws ApiError
     */
    addParticipationKey(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/participation',
            body: data.requestBody,
            mediaType: 'application/msgpack',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Generate and install participation keys to the node.
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.first First round for participation key.
     * @param data.last Last round for participation key.
     * @param data.dilution Key dilution for two-level participation keys (defaults to sqrt of validity window).
     * @returns string An empty JSON object is returned if the generation process was started. Currently no status is available.
     * @throws ApiError
     */
    generateParticipationKeys(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/participation/generate/{address}',
            path: {
                address: data.address
            },
            query: {
                dilution: data.dilution,
                first: data.first,
                last: data.last
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Delete a given participation key by ID
     * Delete a given participation key by ID
     * @param data The data for the request.
     * @param data.participationId
     * @returns unknown Participation key got deleted by ID
     * @throws ApiError
     */
    deleteParticipationKeyById(data) {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/v2/participation/{participation-id}',
            path: {
                'participation-id': data.participationId
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get participation key info given a participation ID
     * Given a participation ID, return information about that participation key
     * @param data The data for the request.
     * @param data.participationId
     * @returns ParticipationKey A detailed description of a participation ID
     * @throws ApiError
     */
    getParticipationKeyById(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/participation/{participation-id}',
            path: {
                'participation-id': data.participationId
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Append state proof keys to a participation key
     * Given a participation ID, append state proof keys to a particular set of participation keys
     * @param data The data for the request.
     * @param data.participationId
     * @param data.requestBody The state proof keys to add to an existing participation ID
     * @returns ParticipationKey A detailed description of a participation ID
     * @throws ApiError
     */
    appendKeys(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/participation/{participation-id}',
            path: {
                'participation-id': data.participationId
            },
            body: data.requestBody,
            mediaType: 'application/msgpack',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
     * @param data The data for the request.
     * @param data.timeout
     * @returns unknown
     * @throws ApiError
     */
    shutdownNode(data = {}) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/shutdown',
            query: {
                timeout: data.timeout
            }
        });
    }
}
export class PublicService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * Gets the genesis information.
     * Returns the entire genesis file in json.
     * @returns string The genesis file in json.
     * @throws ApiError
     */
    getGenesis() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/genesis',
            errors: {
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Returns OK if healthy.
     * @returns unknown OK.
     * @throws ApiError
     */
    healthCheck() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/health',
            errors: {
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Return metrics about algod functioning.
     * @returns unknown text with \#-comments and key:value lines
     * @throws ApiError
     */
    metrics() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/metrics',
            errors: {
                404: 'metrics were compiled out'
            }
        });
    }
    /**
     * Returns OK if healthy and fully caught up.
     * @returns unknown OK.
     * @throws ApiError
     */
    getReady() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/ready',
            errors: {
                500: 'Internal Error',
                503: 'Node not ready yet',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Gets the current swagger spec.
     * Returns the entire swagger spec in json.
     * @returns string The current swagger spec
     * @throws ApiError
     */
    swaggerJson() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/swagger.json',
            errors: {
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get account information.
     * Given a specific account public key, this call returns the accounts status, balance and spendable amounts
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @param data.exclude When set to `all` will exclude asset holdings, application local state, created asset parameters, any created application parameters. Defaults to `none`.
     * @returns Account AccountResponse wraps the Account type in a response.
     * @throws ApiError
     */
    accountInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}',
            path: {
                address: data.address
            },
            query: {
                format: data.format,
                exclude: data.exclude
            },
            errors: {
                400: 'Bad request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get account information about a given app.
     * Given a specific account public key and application ID, this call returns the account's application local state and global state (AppLocalState and AppParams, if either exists). Global state will only be returned if the provided address is the application's creator.
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.applicationId An application identifier
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown AccountApplicationResponse describes the account's application local state and global state (AppLocalState and AppParams, if either exists) for a specific application ID. Global state will only be returned if the provided address is the application's creator.
     * @throws ApiError
     */
    accountApplicationInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}/applications/{application-id}',
            path: {
                address: data.address,
                'application-id': data.applicationId
            },
            query: {
                format: data.format
            },
            errors: {
                400: 'Malformed address or application ID',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a list of assets held by an account, inclusive of asset params.
     * Lookup an account's asset holdings.
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.limit Maximum number of results to return.
     * @param data.next The next page of results. Use the next token provided by the previous results.
     * @returns unknown AccountAssetsInformationResponse contains a list of assets held by an account.
     * @throws ApiError
     */
    accountAssetsInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}/assets',
            path: {
                address: data.address
            },
            query: {
                limit: data.limit,
                next: data.next
            },
            errors: {
                400: 'Malformed address',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get account information about a given asset.
     * Given a specific account public key and asset ID, this call returns the account's asset holding and asset parameters (if either exist). Asset parameters will only be returned if the provided address is the asset's creator.
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.assetId An asset identifier
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown AccountAssetResponse describes the account's asset holding and asset parameters (if either exist) for a specific asset ID. Asset parameters will only be returned if the provided address is the asset's creator.
     * @throws ApiError
     */
    accountAssetInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}/assets/{asset-id}',
            path: {
                address: data.address,
                'asset-id': data.assetId
            },
            query: {
                format: data.format
            },
            errors: {
                400: 'Malformed address or asset ID',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a list of unconfirmed transactions currently in the transaction pool by address.
     * Get the list of pending transactions by address, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
     *
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.max Truncated number of transactions to display. If max=0, returns all pending txns.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown A potentially truncated list of transactions currently in the node's transaction pool. You can compute whether or not the list is truncated if the number of elements in the **top-transactions** array is fewer than **total-transactions**.
     * @throws ApiError
     */
    getPendingTransactionsByAddress(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}/transactions/pending',
            path: {
                address: data.address
            },
            query: {
                max: data.max,
                format: data.format
            },
            errors: {
                400: 'Max must be a non-negative integer',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get application information.
     * Given a application ID, it returns application information including creator, approval and clear programs, global and local schemas, and global state.
     * @param data The data for the request.
     * @param data.applicationId An application identifier
     * @returns Application Application information
     * @throws ApiError
     */
    getApplicationById(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/applications/{application-id}',
            path: {
                'application-id': data.applicationId
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Application Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get box information for a given application.
     * Given an application ID and box name, it returns the round, box name, and value (each base64 encoded). Box names must be in the goal app call arg encoding form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, use the form 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'.
     * @param data The data for the request.
     * @param data.applicationId An application identifier
     * @param data.name A box name, in the goal app call arg form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, use the form 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'.
     * @returns Box Box information
     * @throws ApiError
     */
    getApplicationBoxByName(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/applications/{application-id}/box',
            path: {
                'application-id': data.applicationId
            },
            query: {
                name: data.name
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Box Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get all box names for a given application.
     * Given an application ID, return all Box names. No particular ordering is guaranteed. Request fails when client or server-side configured limits prevent returning all Box names.
     * @param data The data for the request.
     * @param data.applicationId An application identifier
     * @param data.max Max number of box names to return. If max is not set, or max == 0, returns all box-names.
     * @returns unknown Box names of an application
     * @throws ApiError
     */
    getApplicationBoxes(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/applications/{application-id}/boxes',
            path: {
                'application-id': data.applicationId
            },
            query: {
                max: data.max
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get asset information.
     * Given a asset ID, it returns asset information including creator, name, total supply and special addresses.
     * @param data The data for the request.
     * @param data.assetId An asset identifier
     * @returns Asset Asset information
     * @throws ApiError
     */
    getAssetById(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/assets/{asset-id}',
            path: {
                'asset-id': data.assetId
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Application Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get the block for the given round.
     * @param data The data for the request.
     * @param data.round The round from which to fetch block information.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown Encoded block object.
     * @throws ApiError
     */
    getBlock(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}',
            path: {
                round: data.round
            },
            query: {
                format: data.format
            },
            errors: {
                400: 'Bad Request - Non integer number',
                401: 'Invalid API Token',
                404: 'None existing block ',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get the block hash for the block on the given round.
     * @param data The data for the request.
     * @param data.round The round from which to fetch block hash information.
     * @returns unknown Hash of a block header.
     * @throws ApiError
     */
    getBlockHash(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/hash',
            path: {
                round: data.round
            },
            errors: {
                400: 'Bad Request - Non integer number',
                401: 'Invalid API Token',
                404: 'None existing block ',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Gets a proof for a given light block header inside a state proof commitment
     * @param data The data for the request.
     * @param data.round The round to which the light block header belongs.
     * @returns LightBlockHeaderProof Proof of a light block header.
     * @throws ApiError
     */
    getLightBlockHeaderProof(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/lightheader/proof',
            path: {
                round: data.round
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not create proof since some data is missing',
                408: 'timed out on request',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get all of the logs from outer and inner app calls in the given round
     * Get all of the logs from outer and inner app calls in the given round
     * @param data The data for the request.
     * @param data.round The round from which to fetch block log information.
     * @returns unknown All logs emitted in the given round. Each app call, whether top-level or inner, that contains logs results in a separate AppCallLogs object. Therefore there may be multiple AppCallLogs with the same application ID and outer transaction ID in the event of multiple inner app calls to the same app. App calls with no logs are not included in the response. AppCallLogs are returned in the same order that their corresponding app call appeared in the block (pre-order traversal of inner app calls)
     * @throws ApiError
     */
    getBlockLogs(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/logs',
            path: {
                round: data.round
            },
            errors: {
                400: 'Bad Request - Non integer number',
                401: 'Invalid API Token',
                404: 'Nonexistent block ',
                500: 'Internal Error'
            }
        });
    }
    /**
     * Get a proof for a transaction in a block.
     * @param data The data for the request.
     * @param data.round The round in which the transaction appears.
     * @param data.txid The transaction ID for which to generate a proof.
     * @param data.hashtype The type of hash function used to create the proof, must be one of:
     * * sha512_256
     * * sha256
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown Proof of transaction in a block.
     * @throws ApiError
     */
    getTransactionProof(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/transactions/{txid}/proof',
            path: {
                round: data.round,
                txid: data.txid
            },
            query: {
                hashtype: data.hashtype,
                format: data.format
            },
            errors: {
                400: 'Malformed round number or transaction ID',
                401: 'Invalid API token',
                404: 'Non-existent block or transaction',
                500: 'Internal error, including protocol not supporting proofs.',
                default: 'Unknown error'
            }
        });
    }
    /**
     * Get the top level transaction IDs for the block on the given round.
     * @param data The data for the request.
     * @param data.round The round from which to fetch block transaction IDs.
     * @returns unknown Top level transaction IDs in a block.
     * @throws ApiError
     */
    getBlockTxids(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/txids',
            path: {
                round: data.round
            },
            errors: {
                400: 'Bad Request - Non integer number',
                401: 'Invalid API Token',
                404: 'Non existing block',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a LedgerStateDelta object for a given transaction group
     * Get a ledger delta for a given transaction group.
     * @param data The data for the request.
     * @param data.id A transaction ID, or transaction group ID
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns LedgerStateDelta Response containing a ledger state delta for a single transaction group.
     * @throws ApiError
     */
    getLedgerStateDeltaForTransactionGroup(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/deltas/txn/group/{id}',
            path: {
                id: data.id
            },
            query: {
                format: data.format
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not find a delta for transaction ID or group ID',
                408: 'timed out on request',
                500: 'Internal Error',
                501: 'Not Implemented',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a LedgerStateDelta object for a given round
     * Get ledger deltas for a round.
     * @param data The data for the request.
     * @param data.round The round for which the deltas are desired.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns LedgerStateDelta Contains ledger deltas
     * @throws ApiError
     */
    getLedgerStateDelta(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/deltas/{round}',
            path: {
                round: data.round
            },
            query: {
                format: data.format
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not find a delta for round',
                408: 'timed out on request',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get LedgerStateDelta objects for all transaction groups in a given round
     * Get ledger deltas for transaction groups in a given round.
     * @param data The data for the request.
     * @param data.round The round for which the deltas are desired.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown Response containing all ledger state deltas for transaction groups, with their associated Ids, in a single round.
     * @throws ApiError
     */
    getTransactionGroupLedgerStateDeltasForRound(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/deltas/{round}/txn/group',
            path: {
                round: data.round
            },
            query: {
                format: data.format
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not find deltas for round',
                408: 'timed out on request',
                500: 'Internal Error',
                501: 'Not Implemented',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
     * Gets the current timestamp offset.
     * @returns unknown Response containing the timestamp offset in seconds
     * @throws ApiError
     */
    getBlockTimeStampOffset() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/devmode/blocks/offset',
            errors: {
                400: 'TimeStamp offset not set.',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
     * Sets the timestamp offset (seconds) for blocks in dev mode. Providing an offset of 0 will unset this value and try to use the real clock for the timestamp.
     * @param data The data for the request.
     * @param data.offset The timestamp offset for blocks in dev mode.
     * @returns unknown OK
     * @throws ApiError
     */
    setBlockTimeStampOffset(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/devmode/blocks/offset/{offset}',
            path: {
                offset: data.offset
            },
            errors: {
                400: 'Cannot set timestamp offset to a negative integer.',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Returns OK if experimental API is enabled.
     * @returns unknown Experimental API enabled
     * @throws ApiError
     */
    experimentalCheck() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/experimental',
            errors: {
                404: 'Experimental API not enabled',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get the current supply reported by the ledger.
     * @returns unknown Supply represents the current supply of MicroAlgos in the system.
     * @throws ApiError
     */
    getSupply() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/ledger/supply',
            errors: {
                401: 'Invalid API Token',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Removes minimum sync round restriction from the ledger.
     * Unset the ledger sync round.
     * @returns unknown
     * @throws ApiError
     */
    unsetSyncRound() {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/v2/ledger/sync',
            errors: {
                400: 'Sync round not set.',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Returns the minimum sync round the ledger is keeping in cache.
     * Gets the minimum sync round for the ledger.
     * @returns unknown Response containing the ledger's minimum sync round
     * @throws ApiError
     */
    getSyncRound() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/ledger/sync',
            errors: {
                400: 'Sync round not set.',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Given a round, tells the ledger to keep that round in its cache.
     * Sets the minimum sync round on the ledger.
     * @param data The data for the request.
     * @param data.round The round for which the deltas are desired.
     * @returns unknown
     * @throws ApiError
     */
    setSyncRound(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/ledger/sync/{round}',
            path: {
                round: data.round
            },
            errors: {
                400: 'Can not set sync round to an earlier round than the current round.',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a state proof that covers a given round
     * @param data The data for the request.
     * @param data.round The round for which a state proof is desired.
     * @returns StateProof StateProofResponse wraps the StateProof type in a response.
     * @throws ApiError
     */
    getStateProof(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/stateproofs/{round}',
            path: {
                round: data.round
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not find a state proof that covers a given round',
                408: 'timed out on request',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Gets the current node status.
     * @returns unknown
     * @throws ApiError
     */
    getStatus() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/status',
            errors: {
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Gets the node status after waiting for a round after the given round.
     * Waits for a block to appear after round {round} and returns the node's status at the time. There is a 1 minute timeout, when reached the current status is returned regardless of whether or not it is the round after the given round.
     * @param data The data for the request.
     * @param data.round The round to wait until returning status
     * @returns unknown
     * @throws ApiError
     */
    waitForBlock(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/status/wait-for-block-after/{round}',
            path: {
                round: data.round
            },
            errors: {
                400: 'Bad Request -- number must be non-negative integer',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Compile TEAL source code to binary, produce its hash
     * Given TEAL source code in plain text, return base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style). This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
     * @param data The data for the request.
     * @param data.requestBody TEAL source code to be compiled
     * @param data.sourcemap When set to `true`, returns the source map of the program as a JSON. Defaults to `false`.
     * @returns unknown Teal compile Result
     * @throws ApiError
     */
    tealCompile(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/teal/compile',
            query: {
                sourcemap: data.sourcemap
            },
            body: data.requestBody,
            mediaType: 'text/plain',
            errors: {
                400: 'Bad Request - Teal Compile Error',
                401: 'Invalid API Token',
                404: 'Developer API not enabled',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Disassemble program bytes into the TEAL source code.
     * Given the program bytes, return the TEAL source code in plain text. This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
     * @param data The data for the request.
     * @param data.requestBody TEAL program binary to be disassembled
     * @returns unknown Teal disassembly Result
     * @throws ApiError
     */
    tealDisassemble(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/teal/disassemble',
            body: data.requestBody,
            mediaType: 'application/x-binary',
            errors: {
                400: 'Bad Request - Teal Compile Error',
                401: 'Invalid API Token',
                404: 'Developer API not enabled',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Provide debugging information for a transaction (or group).
     * Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
     * @param data The data for the request.
     * @param data.requestBody Transaction (or group) and any accompanying state-simulation data.
     * @returns unknown DryrunResponse contains per-txn debug information from a dryrun.
     * @throws ApiError
     */
    tealDryrun(data = {}) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/teal/dryrun',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Developer API not enabled',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Broadcasts a raw transaction or transaction group to the network.
     * @param data The data for the request.
     * @param data.requestBody The byte encoded signed transaction to broadcast to network
     * @returns unknown Transaction ID of the submission.
     * @throws ApiError
     */
    rawTransaction(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/transactions',
            body: data.requestBody,
            mediaType: 'application/x-binary',
            errors: {
                400: 'Bad Request - Malformed Algorand transaction ',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get parameters for constructing a new transaction
     * @returns unknown TransactionParams contains the parameters that help a client construct a new transaction.
     * @throws ApiError
     */
    transactionParams() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/transactions/params',
            errors: {
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a list of unconfirmed transactions currently in the transaction pool.
     * Get the list of pending transactions, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
     *
     * @param data The data for the request.
     * @param data.max Truncated number of transactions to display. If max=0, returns all pending txns.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown A potentially truncated list of transactions currently in the node's transaction pool. You can compute whether or not the list is truncated if the number of elements in the **top-transactions** array is fewer than **total-transactions**.
     * @throws ApiError
     */
    getPendingTransactions(data = {}) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/transactions/pending',
            query: {
                max: data.max,
                format: data.format
            },
            errors: {
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a specific pending transaction.
     * Given a transaction ID of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed:
     * - transaction committed (committed round > 0)
     * - transaction still in the pool (committed round = 0, pool error = "")
     * - transaction removed from pool due to error (committed round = 0, pool error != "")
     * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
     *
     * @param data The data for the request.
     * @param data.txid A transaction ID
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns PendingTransactionResponse Given a transaction ID of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed:
     * - transaction committed (committed round > 0)
     * - transaction still in the pool (committed round = 0, pool error = "")
     * - transaction removed from pool due to error (committed round = 0, pool error != "")
     *
     * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
     * @throws ApiError
     */
    pendingTransactionInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/transactions/pending/{txid}',
            path: {
                txid: data.txid
            },
            query: {
                format: data.format
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Transaction Not Found',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
     * @param data The data for the request.
     * @param data.requestBody The transactions to simulate, along with any other inputs.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown Result of a transaction group simulation.
     * @throws ApiError
     */
    simulateTransaction(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/transactions/simulate',
            query: {
                format: data.format
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Retrieves the supported API versions, binary build versions, and genesis information.
     * @returns Version VersionsResponse is the response to 'GET /versions'
     * @throws ApiError
     */
    getVersion() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/versions'
        });
    }
}
export class CommonService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * Gets the genesis information.
     * Returns the entire genesis file in json.
     * @returns string The genesis file in json.
     * @throws ApiError
     */
    getGenesis() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/genesis',
            errors: {
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Returns OK if healthy.
     * @returns unknown OK.
     * @throws ApiError
     */
    healthCheck() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/health',
            errors: {
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Return metrics about algod functioning.
     * @returns unknown text with \#-comments and key:value lines
     * @throws ApiError
     */
    metrics() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/metrics',
            errors: {
                404: 'metrics were compiled out'
            }
        });
    }
    /**
     * Returns OK if healthy and fully caught up.
     * @returns unknown OK.
     * @throws ApiError
     */
    getReady() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/ready',
            errors: {
                500: 'Internal Error',
                503: 'Node not ready yet',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Gets the current swagger spec.
     * Returns the entire swagger spec in json.
     * @returns string The current swagger spec
     * @throws ApiError
     */
    swaggerJson() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/swagger.json',
            errors: {
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Retrieves the supported API versions, binary build versions, and genesis information.
     * @returns Version VersionsResponse is the response to 'GET /versions'
     * @throws ApiError
     */
    getVersion() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/versions'
        });
    }
}
export class NonparticipatingService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * Get account information.
     * Given a specific account public key, this call returns the accounts status, balance and spendable amounts
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @param data.exclude When set to `all` will exclude asset holdings, application local state, created asset parameters, any created application parameters. Defaults to `none`.
     * @returns Account AccountResponse wraps the Account type in a response.
     * @throws ApiError
     */
    accountInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}',
            path: {
                address: data.address
            },
            query: {
                format: data.format,
                exclude: data.exclude
            },
            errors: {
                400: 'Bad request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get account information about a given app.
     * Given a specific account public key and application ID, this call returns the account's application local state and global state (AppLocalState and AppParams, if either exists). Global state will only be returned if the provided address is the application's creator.
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.applicationId An application identifier
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown AccountApplicationResponse describes the account's application local state and global state (AppLocalState and AppParams, if either exists) for a specific application ID. Global state will only be returned if the provided address is the application's creator.
     * @throws ApiError
     */
    accountApplicationInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}/applications/{application-id}',
            path: {
                address: data.address,
                'application-id': data.applicationId
            },
            query: {
                format: data.format
            },
            errors: {
                400: 'Malformed address or application ID',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get account information about a given asset.
     * Given a specific account public key and asset ID, this call returns the account's asset holding and asset parameters (if either exist). Asset parameters will only be returned if the provided address is the asset's creator.
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.assetId An asset identifier
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown AccountAssetResponse describes the account's asset holding and asset parameters (if either exist) for a specific asset ID. Asset parameters will only be returned if the provided address is the asset's creator.
     * @throws ApiError
     */
    accountAssetInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}/assets/{asset-id}',
            path: {
                address: data.address,
                'asset-id': data.assetId
            },
            query: {
                format: data.format
            },
            errors: {
                400: 'Malformed address or asset ID',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get application information.
     * Given a application ID, it returns application information including creator, approval and clear programs, global and local schemas, and global state.
     * @param data The data for the request.
     * @param data.applicationId An application identifier
     * @returns Application Application information
     * @throws ApiError
     */
    getApplicationById(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/applications/{application-id}',
            path: {
                'application-id': data.applicationId
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Application Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get box information for a given application.
     * Given an application ID and box name, it returns the round, box name, and value (each base64 encoded). Box names must be in the goal app call arg encoding form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, use the form 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'.
     * @param data The data for the request.
     * @param data.applicationId An application identifier
     * @param data.name A box name, in the goal app call arg form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, use the form 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'.
     * @returns Box Box information
     * @throws ApiError
     */
    getApplicationBoxByName(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/applications/{application-id}/box',
            path: {
                'application-id': data.applicationId
            },
            query: {
                name: data.name
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Box Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get all box names for a given application.
     * Given an application ID, return all Box names. No particular ordering is guaranteed. Request fails when client or server-side configured limits prevent returning all Box names.
     * @param data The data for the request.
     * @param data.applicationId An application identifier
     * @param data.max Max number of box names to return. If max is not set, or max == 0, returns all box-names.
     * @returns unknown Box names of an application
     * @throws ApiError
     */
    getApplicationBoxes(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/applications/{application-id}/boxes',
            path: {
                'application-id': data.applicationId
            },
            query: {
                max: data.max
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get asset information.
     * Given a asset ID, it returns asset information including creator, name, total supply and special addresses.
     * @param data The data for the request.
     * @param data.assetId An asset identifier
     * @returns Asset Asset information
     * @throws ApiError
     */
    getAssetById(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/assets/{asset-id}',
            path: {
                'asset-id': data.assetId
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Application Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get the block for the given round.
     * @param data The data for the request.
     * @param data.round The round from which to fetch block information.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown Encoded block object.
     * @throws ApiError
     */
    getBlock(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}',
            path: {
                round: data.round
            },
            query: {
                format: data.format
            },
            errors: {
                400: 'Bad Request - Non integer number',
                401: 'Invalid API Token',
                404: 'None existing block ',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get the block hash for the block on the given round.
     * @param data The data for the request.
     * @param data.round The round from which to fetch block hash information.
     * @returns unknown Hash of a block header.
     * @throws ApiError
     */
    getBlockHash(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/hash',
            path: {
                round: data.round
            },
            errors: {
                400: 'Bad Request - Non integer number',
                401: 'Invalid API Token',
                404: 'None existing block ',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Gets a proof for a given light block header inside a state proof commitment
     * @param data The data for the request.
     * @param data.round The round to which the light block header belongs.
     * @returns LightBlockHeaderProof Proof of a light block header.
     * @throws ApiError
     */
    getLightBlockHeaderProof(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/lightheader/proof',
            path: {
                round: data.round
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not create proof since some data is missing',
                408: 'timed out on request',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get all of the logs from outer and inner app calls in the given round
     * Get all of the logs from outer and inner app calls in the given round
     * @param data The data for the request.
     * @param data.round The round from which to fetch block log information.
     * @returns unknown All logs emitted in the given round. Each app call, whether top-level or inner, that contains logs results in a separate AppCallLogs object. Therefore there may be multiple AppCallLogs with the same application ID and outer transaction ID in the event of multiple inner app calls to the same app. App calls with no logs are not included in the response. AppCallLogs are returned in the same order that their corresponding app call appeared in the block (pre-order traversal of inner app calls)
     * @throws ApiError
     */
    getBlockLogs(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/logs',
            path: {
                round: data.round
            },
            errors: {
                400: 'Bad Request - Non integer number',
                401: 'Invalid API Token',
                404: 'Nonexistent block ',
                500: 'Internal Error'
            }
        });
    }
    /**
     * Get a proof for a transaction in a block.
     * @param data The data for the request.
     * @param data.round The round in which the transaction appears.
     * @param data.txid The transaction ID for which to generate a proof.
     * @param data.hashtype The type of hash function used to create the proof, must be one of:
     * * sha512_256
     * * sha256
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown Proof of transaction in a block.
     * @throws ApiError
     */
    getTransactionProof(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/transactions/{txid}/proof',
            path: {
                round: data.round,
                txid: data.txid
            },
            query: {
                hashtype: data.hashtype,
                format: data.format
            },
            errors: {
                400: 'Malformed round number or transaction ID',
                401: 'Invalid API token',
                404: 'Non-existent block or transaction',
                500: 'Internal error, including protocol not supporting proofs.',
                default: 'Unknown error'
            }
        });
    }
    /**
     * Get the top level transaction IDs for the block on the given round.
     * @param data The data for the request.
     * @param data.round The round from which to fetch block transaction IDs.
     * @returns unknown Top level transaction IDs in a block.
     * @throws ApiError
     */
    getBlockTxids(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/blocks/{round}/txids',
            path: {
                round: data.round
            },
            errors: {
                400: 'Bad Request - Non integer number',
                401: 'Invalid API Token',
                404: 'Non existing block',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Aborts a catchpoint catchup.
     * Given a catchpoint, it aborts catching up to this catchpoint
     * @param data The data for the request.
     * @param data.catchpoint A catch point
     * @returns unknown
     * @throws ApiError
     */
    abortCatchup(data) {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/v2/catchup/{catchpoint}',
            path: {
                catchpoint: data.catchpoint
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Starts a catchpoint catchup.
     * Given a catchpoint, it starts catching up to this catchpoint
     * @param data The data for the request.
     * @param data.catchpoint A catch point
     * @param data.min Specify the minimum number of blocks which the ledger must be advanced by in order to start the catchup. This is useful for simplifying tools which support fast catchup, they can run the catchup unconditionally and the node will skip the catchup if it is not needed.
     * @returns unknown
     * @returns unknown
     * @throws ApiError
     */
    startCatchup(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/catchup/{catchpoint}',
            path: {
                catchpoint: data.catchpoint
            },
            query: {
                min: data.min
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                408: 'Request Timeout',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a LedgerStateDelta object for a given transaction group
     * Get a ledger delta for a given transaction group.
     * @param data The data for the request.
     * @param data.id A transaction ID, or transaction group ID
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns LedgerStateDelta Response containing a ledger state delta for a single transaction group.
     * @throws ApiError
     */
    getLedgerStateDeltaForTransactionGroup(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/deltas/txn/group/{id}',
            path: {
                id: data.id
            },
            query: {
                format: data.format
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not find a delta for transaction ID or group ID',
                408: 'timed out on request',
                500: 'Internal Error',
                501: 'Not Implemented',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a LedgerStateDelta object for a given round
     * Get ledger deltas for a round.
     * @param data The data for the request.
     * @param data.round The round for which the deltas are desired.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns LedgerStateDelta Contains ledger deltas
     * @throws ApiError
     */
    getLedgerStateDelta(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/deltas/{round}',
            path: {
                round: data.round
            },
            query: {
                format: data.format
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not find a delta for round',
                408: 'timed out on request',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get LedgerStateDelta objects for all transaction groups in a given round
     * Get ledger deltas for transaction groups in a given round.
     * @param data The data for the request.
     * @param data.round The round for which the deltas are desired.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown Response containing all ledger state deltas for transaction groups, with their associated Ids, in a single round.
     * @throws ApiError
     */
    getTransactionGroupLedgerStateDeltasForRound(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/deltas/{round}/txn/group',
            path: {
                round: data.round
            },
            query: {
                format: data.format
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not find deltas for round',
                408: 'timed out on request',
                500: 'Internal Error',
                501: 'Not Implemented',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
     * Gets the current timestamp offset.
     * @returns unknown Response containing the timestamp offset in seconds
     * @throws ApiError
     */
    getBlockTimeStampOffset() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/devmode/blocks/offset',
            errors: {
                400: 'TimeStamp offset not set.',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
     * Sets the timestamp offset (seconds) for blocks in dev mode. Providing an offset of 0 will unset this value and try to use the real clock for the timestamp.
     * @param data The data for the request.
     * @param data.offset The timestamp offset for blocks in dev mode.
     * @returns unknown OK
     * @throws ApiError
     */
    setBlockTimeStampOffset(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/devmode/blocks/offset/{offset}',
            path: {
                offset: data.offset
            },
            errors: {
                400: 'Cannot set timestamp offset to a negative integer.',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get the current supply reported by the ledger.
     * @returns unknown Supply represents the current supply of MicroAlgos in the system.
     * @throws ApiError
     */
    getSupply() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/ledger/supply',
            errors: {
                401: 'Invalid API Token',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
     * @param data The data for the request.
     * @param data.timeout
     * @returns unknown
     * @throws ApiError
     */
    shutdownNode(data = {}) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/shutdown',
            query: {
                timeout: data.timeout
            }
        });
    }
    /**
     * Get a state proof that covers a given round
     * @param data The data for the request.
     * @param data.round The round for which a state proof is desired.
     * @returns StateProof StateProofResponse wraps the StateProof type in a response.
     * @throws ApiError
     */
    getStateProof(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/stateproofs/{round}',
            path: {
                round: data.round
            },
            errors: {
                401: 'Invalid API Token',
                404: 'Could not find a state proof that covers a given round',
                408: 'timed out on request',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Gets the current node status.
     * @returns unknown
     * @throws ApiError
     */
    getStatus() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/status',
            errors: {
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Gets the node status after waiting for a round after the given round.
     * Waits for a block to appear after round {round} and returns the node's status at the time. There is a 1 minute timeout, when reached the current status is returned regardless of whether or not it is the round after the given round.
     * @param data The data for the request.
     * @param data.round The round to wait until returning status
     * @returns unknown
     * @throws ApiError
     */
    waitForBlock(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/status/wait-for-block-after/{round}',
            path: {
                round: data.round
            },
            errors: {
                400: 'Bad Request -- number must be non-negative integer',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Compile TEAL source code to binary, produce its hash
     * Given TEAL source code in plain text, return base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style). This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
     * @param data The data for the request.
     * @param data.requestBody TEAL source code to be compiled
     * @param data.sourcemap When set to `true`, returns the source map of the program as a JSON. Defaults to `false`.
     * @returns unknown Teal compile Result
     * @throws ApiError
     */
    tealCompile(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/teal/compile',
            query: {
                sourcemap: data.sourcemap
            },
            body: data.requestBody,
            mediaType: 'text/plain',
            errors: {
                400: 'Bad Request - Teal Compile Error',
                401: 'Invalid API Token',
                404: 'Developer API not enabled',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Disassemble program bytes into the TEAL source code.
     * Given the program bytes, return the TEAL source code in plain text. This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
     * @param data The data for the request.
     * @param data.requestBody TEAL program binary to be disassembled
     * @returns unknown Teal disassembly Result
     * @throws ApiError
     */
    tealDisassemble(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/teal/disassemble',
            body: data.requestBody,
            mediaType: 'application/x-binary',
            errors: {
                400: 'Bad Request - Teal Compile Error',
                401: 'Invalid API Token',
                404: 'Developer API not enabled',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Provide debugging information for a transaction (or group).
     * Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
     * @param data The data for the request.
     * @param data.requestBody Transaction (or group) and any accompanying state-simulation data.
     * @returns unknown DryrunResponse contains per-txn debug information from a dryrun.
     * @throws ApiError
     */
    tealDryrun(data = {}) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/teal/dryrun',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Developer API not enabled',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get parameters for constructing a new transaction
     * @returns unknown TransactionParams contains the parameters that help a client construct a new transaction.
     * @throws ApiError
     */
    transactionParams() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/transactions/params',
            errors: {
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
     * @param data The data for the request.
     * @param data.requestBody The transactions to simulate, along with any other inputs.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown Result of a transaction group simulation.
     * @throws ApiError
     */
    simulateTransaction(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/transactions/simulate',
            query: {
                format: data.format
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
}
export class ExperimentalService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * Get a list of assets held by an account, inclusive of asset params.
     * Lookup an account's asset holdings.
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.limit Maximum number of results to return.
     * @param data.next The next page of results. Use the next token provided by the previous results.
     * @returns unknown AccountAssetsInformationResponse contains a list of assets held by an account.
     * @throws ApiError
     */
    accountAssetsInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}/assets',
            path: {
                address: data.address
            },
            query: {
                limit: data.limit,
                next: data.next
            },
            errors: {
                400: 'Malformed address',
                401: 'Invalid API Token',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Returns OK if experimental API is enabled.
     * @returns unknown Experimental API enabled
     * @throws ApiError
     */
    experimentalCheck() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/experimental',
            errors: {
                404: 'Experimental API not enabled',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Fast track for broadcasting a raw transaction or transaction group to the network through the tx handler without performing most of the checks and reporting detailed errors. Should be only used for development and performance testing.
     * @param data The data for the request.
     * @param data.requestBody The byte encoded signed transaction to broadcast to network
     * @returns unknown
     * @throws ApiError
     */
    rawTransactionAsync(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/transactions/async',
            body: data.requestBody,
            mediaType: 'application/x-binary',
            errors: {
                400: 'Bad Request - Malformed Algorand transaction ',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
}
export class ParticipatingService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * Get a list of unconfirmed transactions currently in the transaction pool by address.
     * Get the list of pending transactions by address, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
     *
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.max Truncated number of transactions to display. If max=0, returns all pending txns.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown A potentially truncated list of transactions currently in the node's transaction pool. You can compute whether or not the list is truncated if the number of elements in the **top-transactions** array is fewer than **total-transactions**.
     * @throws ApiError
     */
    getPendingTransactionsByAddress(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/accounts/{address}/transactions/pending',
            path: {
                address: data.address
            },
            query: {
                max: data.max,
                format: data.format
            },
            errors: {
                400: 'Max must be a non-negative integer',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Return a list of participation keys
     * Return a list of participation keys
     * @returns ParticipationKey A list of participation keys
     * @throws ApiError
     */
    getParticipationKeys() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/participation',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Add a participation key to the node
     * @param data The data for the request.
     * @param data.requestBody The participation key to add to the node
     * @returns unknown Participation ID of the submission
     * @throws ApiError
     */
    addParticipationKey(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/participation',
            body: data.requestBody,
            mediaType: 'application/msgpack',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Generate and install participation keys to the node.
     * @param data The data for the request.
     * @param data.address An account public key
     * @param data.first First round for participation key.
     * @param data.last Last round for participation key.
     * @param data.dilution Key dilution for two-level participation keys (defaults to sqrt of validity window).
     * @returns string An empty JSON object is returned if the generation process was started. Currently no status is available.
     * @throws ApiError
     */
    generateParticipationKeys(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/participation/generate/{address}',
            path: {
                address: data.address
            },
            query: {
                dilution: data.dilution,
                first: data.first,
                last: data.last
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Delete a given participation key by ID
     * Delete a given participation key by ID
     * @param data The data for the request.
     * @param data.participationId
     * @returns unknown Participation key got deleted by ID
     * @throws ApiError
     */
    deleteParticipationKeyById(data) {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/v2/participation/{participation-id}',
            path: {
                'participation-id': data.participationId
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get participation key info given a participation ID
     * Given a participation ID, return information about that participation key
     * @param data The data for the request.
     * @param data.participationId
     * @returns ParticipationKey A detailed description of a participation ID
     * @throws ApiError
     */
    getParticipationKeyById(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/participation/{participation-id}',
            path: {
                'participation-id': data.participationId
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Append state proof keys to a participation key
     * Given a participation ID, append state proof keys to a particular set of participation keys
     * @param data The data for the request.
     * @param data.participationId
     * @param data.requestBody The state proof keys to add to an existing participation ID
     * @returns ParticipationKey A detailed description of a participation ID
     * @throws ApiError
     */
    appendKeys(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/participation/{participation-id}',
            path: {
                'participation-id': data.participationId
            },
            body: data.requestBody,
            mediaType: 'application/msgpack',
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Participation Key Not Found',
                500: 'Internal Error',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Broadcasts a raw transaction or transaction group to the network.
     * @param data The data for the request.
     * @param data.requestBody The byte encoded signed transaction to broadcast to network
     * @returns unknown Transaction ID of the submission.
     * @throws ApiError
     */
    rawTransaction(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/transactions',
            body: data.requestBody,
            mediaType: 'application/x-binary',
            errors: {
                400: 'Bad Request - Malformed Algorand transaction ',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a list of unconfirmed transactions currently in the transaction pool.
     * Get the list of pending transactions, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
     *
     * @param data The data for the request.
     * @param data.max Truncated number of transactions to display. If max=0, returns all pending txns.
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns unknown A potentially truncated list of transactions currently in the node's transaction pool. You can compute whether or not the list is truncated if the number of elements in the **top-transactions** array is fewer than **total-transactions**.
     * @throws ApiError
     */
    getPendingTransactions(data = {}) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/transactions/pending',
            query: {
                max: data.max,
                format: data.format
            },
            errors: {
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Get a specific pending transaction.
     * Given a transaction ID of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed:
     * - transaction committed (committed round > 0)
     * - transaction still in the pool (committed round = 0, pool error = "")
     * - transaction removed from pool due to error (committed round = 0, pool error != "")
     * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
     *
     * @param data The data for the request.
     * @param data.txid A transaction ID
     * @param data.format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
     * @returns PendingTransactionResponse Given a transaction ID of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed:
     * - transaction committed (committed round > 0)
     * - transaction still in the pool (committed round = 0, pool error = "")
     * - transaction removed from pool due to error (committed round = 0, pool error != "")
     *
     * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
     * @throws ApiError
     */
    pendingTransactionInformation(data) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/transactions/pending/{txid}',
            path: {
                txid: data.txid
            },
            query: {
                format: data.format
            },
            errors: {
                400: 'Bad Request',
                401: 'Invalid API Token',
                404: 'Transaction Not Found',
                default: 'Unknown Error'
            }
        });
    }
}
export class DataService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * Removes minimum sync round restriction from the ledger.
     * Unset the ledger sync round.
     * @returns unknown
     * @throws ApiError
     */
    unsetSyncRound() {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/v2/ledger/sync',
            errors: {
                400: 'Sync round not set.',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Returns the minimum sync round the ledger is keeping in cache.
     * Gets the minimum sync round for the ledger.
     * @returns unknown Response containing the ledger's minimum sync round
     * @throws ApiError
     */
    getSyncRound() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v2/ledger/sync',
            errors: {
                400: 'Sync round not set.',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
    /**
     * Given a round, tells the ledger to keep that round in its cache.
     * Sets the minimum sync round on the ledger.
     * @param data The data for the request.
     * @param data.round The round for which the deltas are desired.
     * @returns unknown
     * @throws ApiError
     */
    setSyncRound(data) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v2/ledger/sync/{round}',
            path: {
                round: data.round
            },
            errors: {
                400: 'Can not set sync round to an earlier round than the current round.',
                401: 'Invalid API Token',
                500: 'Internal Error',
                503: 'Service Temporarily Unavailable',
                default: 'Unknown Error'
            }
        });
    }
}
